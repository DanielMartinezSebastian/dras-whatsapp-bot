/**
 * Basic Command Handlers
 *
 * This file implements handlers for the fundamental commands for the DrasBot system.
 * Includes help, status, user configuration, and registration commands.
 */

import { Logger } from '../utils/logger';
import { WhatsAppBridgeService } from '../services/whatsapp-bridge.service';
import { ContextManagerService } from '../services/context-manager.service';
import {
  PluginContext,
  CommandResult,
  UserLevel,
  Message,
  ContextType,
} from '../types';

/**
 * Help Command Handler - Shows available commands
 */
export const handleHelpCommand = async (
  message: Message,
  context: PluginContext
): Promise<CommandResult> => {
  const logger = Logger.getInstance();
  const args = message.content.split(' ').slice(1);

  try {
    if (args.length > 0) {
      // Show help for specific command
      const commandName = args[0].toLowerCase();

      // TODO: Get command details from CommandRegistry
      return {
        success: true,
        message:
          `üìñ **Ayuda para el comando: ${commandName}**\n\n` +
          `Informaci√≥n detallada del comando aqu√≠.\n\n` +
          `Usa \`!help\` para ver todos los comandos disponibles.`,
        data: { commandName, type: 'specific_help' },
      };
    }

    // Show general help
    const userLevel = context.user.userLevel;
    let helpText = `ü§ñ **DrasBot - Comandos Disponibles**\n\n`;

    // Basic commands for all users
    helpText += `**üìã Comandos Generales:**\n`;
    helpText += `‚Ä¢ \`!help\` - Muestra esta ayuda\n`;
    helpText += `‚Ä¢ \`!status\` - Estado del bot\n`;
    helpText += `‚Ä¢ \`!config\` - Configuraci√≥n personal\n`;
    helpText += `‚Ä¢ \`!registro\` - Registrarse en el sistema\n\n`;

    // Bridge commands for all users
    helpText += `**üåâ Comandos del Bridge:**\n`;
    helpText += `‚Ä¢ \`!bridge\` - Estado del bridge de WhatsApp\n`;
    helpText += `‚Ä¢ \`!chats\` - Lista de chats recientes\n`;
    helpText += `‚Ä¢ \`!history\` - Historial de mensajes\n\n`;

    // Moderator commands
    if (
      userLevel === UserLevel.MODERATOR ||
      userLevel === UserLevel.ADMIN ||
      userLevel === UserLevel.OWNER
    ) {
      helpText += `**üõ°Ô∏è Comandos de Moderaci√≥n:**\n`;
      helpText += `‚Ä¢ \`!users\` - Gesti√≥n de usuarios\n`;
      helpText += `‚Ä¢ \`!stats\` - Estad√≠sticas del bot\n\n`;
    }

    // Admin commands
    if (userLevel === UserLevel.ADMIN || userLevel === UserLevel.OWNER) {
      helpText += `**‚öôÔ∏è Comandos de Administraci√≥n:**\n`;
      helpText += `‚Ä¢ \`!admin\` - Panel de administraci√≥n\n`;
      helpText += `‚Ä¢ \`!plugins\` - Gesti√≥n de plugins\n`;
      helpText += `‚Ä¢ \`!backup\` - Backup del sistema\n`;
      helpText += `‚Ä¢ \`!qr\` - C√≥digo QR para conectar WhatsApp\n`;
      helpText += `‚Ä¢ \`!bridgehealth\` - Verificar salud del bridge\n\n`;
    }

    helpText += `üí° **Tip:** Usa \`!help [comando]\` para m√°s informaci√≥n sobre un comando espec√≠fico.`;

    return {
      success: true,
      message: helpText,
      data: { type: 'general_help', userLevel },
    };
  } catch (error) {
    logger.error('HelpCommand', 'Error executing help command', { error });
    return {
      success: false,
      message: 'Error al mostrar la ayuda. Int√©ntalo de nuevo.',
      data: { error: error instanceof Error ? error.message : String(error) },
    };
  }
};

/**
 * Status Command Handler - Shows bot status and statistics
 */
export const handleStatusCommand = async (
  _message: Message,
  context: PluginContext
): Promise<CommandResult> => {
  const logger = Logger.getInstance();

  try {
    const whatsappBridge = WhatsAppBridgeService.getInstance();
    const contextManager = ContextManagerService.getInstance();

    // Get system status
    const bridgeStatus = whatsappBridge.getStatus();
    const contextStats = contextManager.getStats();

    // Build status message
    let statusText = `ü§ñ **Estado del DrasBot**\n\n`;

    // Basic system status
    statusText += `**üîó Conexi√≥n WhatsApp:**\n`;
    statusText += `‚Ä¢ Estado: ${bridgeStatus.connected ? '‚úÖ Conectado' : '‚ùå Desconectado'}\n`;
    statusText += `‚Ä¢ √öltima verificaci√≥n: ${bridgeStatus.lastHealthCheck || 'N/A'}\n\n`;

    // Context statistics
    statusText += `**üìä Contextos Activos:**\n`;
    statusText += `‚Ä¢ Contextos activos: ${contextStats.activeContexts}\n`;
    statusText += `‚Ä¢ Handlers registrados: ${contextStats.totalHandlers}\n`;
    statusText += `‚Ä¢ Detecciones realizadas: ${contextStats.totalDetections}\n`;
    statusText += `‚Ä¢ Ejecuciones totales: ${contextStats.totalExecutions}\n\n`;

    // User level specific information
    if (
      context.user.userLevel === UserLevel.ADMIN ||
      context.user.userLevel === UserLevel.OWNER
    ) {
      statusText += `**‚öôÔ∏è Informaci√≥n de Sistema:**\n`;
      statusText += `‚Ä¢ Uptime: ${process.uptime().toFixed(0)}s\n`;
      statusText += `‚Ä¢ Memoria usada: ${(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)} MB\n`;
      statusText += `‚Ä¢ Versi√≥n Node.js: ${process.version}\n\n`;
    }

    statusText += `‚è∞ √öltima actualizaci√≥n: ${new Date().toLocaleString('es-ES')}`;

    return {
      success: true,
      message: statusText,
      data: {
        type: 'status_info',
        bridgeStatus,
        contextStats,
        timestamp: new Date().toISOString(),
      },
    };
  } catch (error) {
    logger.error('StatusCommand', 'Error executing status command', { error });
    return {
      success: false,
      message: 'Error al obtener el estado del bot. Int√©ntalo de nuevo.',
      data: { error: error instanceof Error ? error.message : String(error) },
    };
  }
};

/**
 * Config Command Handler - User configuration management
 */
export const handleConfigCommand = async (
  message: Message,
  context: PluginContext
): Promise<CommandResult> => {
  const logger = Logger.getInstance();
  const contextManager = ContextManagerService.getInstance();
  const args = message.content.split(' ').slice(1);

  try {
    if (args.length === 0) {
      // Show current configuration
      const userPrefs = context.user.preferences;

      let configText = `‚öôÔ∏è **Tu Configuraci√≥n Actual**\n\n`;
      configText += `**üîî Notificaciones:** ${userPrefs.notifications ? 'Activadas' : 'Desactivadas'}\n`;
      configText += `**ü§ñ Respuesta autom√°tica:** ${userPrefs.auto_reply ? 'Activada' : 'Desactivada'}\n`;
      configText += `**üåç Idioma:** ${userPrefs.language || 'es'}\n`;
      configText += `**üïê Zona horaria:** ${userPrefs.timezone || 'UTC'}\n`;
      configText += `**üîí Privacidad:** ${userPrefs.privacy_level || 'normal'}\n\n`;

      configText += `üí° **Cambiar configuraci√≥n:**\n`;
      configText += `‚Ä¢ \`!config notifications on/off\`\n`;
      configText += `‚Ä¢ \`!config auto_reply on/off\`\n`;
      configText += `‚Ä¢ \`!config language es/en\`\n`;
      configText += `‚Ä¢ \`!config privacy open/normal/strict\``;

      return {
        success: true,
        message: configText,
        data: { type: 'show_config', preferences: userPrefs },
      };
    }

    if (args.length === 1) {
      const setting = args[0].toLowerCase();

      // Start configuration context for this setting
      await contextManager.createSpecificContext(
        context.user.id.toString(),
        ContextType.CONFIGURATION,
        {
          setting,
          step: 'awaiting_value',
          userId: context.user.id,
        }
      );

      let settingName = '';
      let currentValue = '';
      let options = '';

      switch (setting) {
        case 'notifications':
        case 'notificaciones':
          settingName = 'Notificaciones';
          currentValue = context.user.preferences.notifications
            ? 'activadas'
            : 'desactivadas';
          options = 'on/off, activar/desactivar, s√≠/no';
          break;
        case 'auto_reply':
        case 'respuesta_automatica':
          settingName = 'Respuesta autom√°tica';
          currentValue = context.user.preferences.auto_reply
            ? 'activada'
            : 'desactivada';
          options = 'on/off, activar/desactivar, s√≠/no';
          break;
        case 'language':
        case 'idioma':
          settingName = 'Idioma';
          currentValue = context.user.preferences.language || 'es';
          options = 'es, en';
          break;
        case 'privacy':
        case 'privacidad':
          settingName = 'Nivel de privacidad';
          currentValue = context.user.preferences.privacy_level || 'normal';
          options = 'open, normal, strict';
          break;
        default:
          return {
            success: false,
            message: `‚ùå Configuraci√≥n "${setting}" no reconocida.\n\nUsa \`!config\` para ver las opciones disponibles.`,
            data: { error: 'unknown_setting', setting },
          };
      }

      return {
        success: true,
        message:
          `‚öôÔ∏è **Configurar ${settingName}**\n\n` +
          `Valor actual: **${currentValue}**\n\n` +
          `Escribe el nuevo valor (${options}):`,
        data: {
          type: 'config_prompt',
          setting,
          settingName,
          currentValue,
          contextCreated: true,
        },
      };
    }

    if (args.length >= 2) {
      const setting = args[0].toLowerCase();
      const value = args.slice(1).join(' ').toLowerCase();

      // TODO: Implement actual configuration update to database
      // For now, we'll just simulate the update

      let updateMessage = '';
      let success = true;

      switch (setting) {
        case 'notifications':
        case 'notificaciones':
          const notifValue = [
            'on',
            'activar',
            's√≠',
            'si',
            'yes',
            'true',
          ].includes(value);
          updateMessage = `‚úÖ Notificaciones ${notifValue ? 'activadas' : 'desactivadas'} correctamente.`;
          break;
        case 'auto_reply':
        case 'respuesta_automatica':
          const autoValue = [
            'on',
            'activar',
            's√≠',
            'si',
            'yes',
            'true',
          ].includes(value);
          updateMessage = `‚úÖ Respuesta autom√°tica ${autoValue ? 'activada' : 'desactivada'} correctamente.`;
          break;
        case 'language':
        case 'idioma':
          if (['es', 'en'].includes(value)) {
            updateMessage = `‚úÖ Idioma cambiado a ${value === 'es' ? 'Espa√±ol' : 'English'} correctamente.`;
          } else {
            success = false;
            updateMessage = `‚ùå Idioma "${value}" no soportado. Usa: es, en`;
          }
          break;
        case 'privacy':
        case 'privacidad':
          if (['open', 'normal', 'strict'].includes(value)) {
            updateMessage = `‚úÖ Nivel de privacidad cambiado a "${value}" correctamente.`;
          } else {
            success = false;
            updateMessage = `‚ùå Nivel de privacidad "${value}" no v√°lido. Usa: open, normal, strict`;
          }
          break;
        default:
          success = false;
          updateMessage = `‚ùå Configuraci√≥n "${setting}" no reconocida.`;
      }

      return {
        success,
        message: updateMessage,
        data: {
          type: success ? 'config_updated' : 'config_error',
          setting,
          value,
          updated: success,
        },
      };
    }

    // This should never be reached, but TypeScript requires it
    return {
      success: false,
      message: 'Error en el comando de configuraci√≥n.',
      data: { error: 'unexpected_flow' },
    };
  } catch (error) {
    logger.error('ConfigCommand', 'Error executing config command', { error });
    return {
      success: false,
      message: 'Error al gestionar la configuraci√≥n. Int√©ntalo de nuevo.',
      data: { error: error instanceof Error ? error.message : String(error) },
    };
  }
};

/**
 * Registration Command Handler - User registration process
 */
export const handleRegistrationCommand = async (
  _message: Message,
  context: PluginContext
): Promise<CommandResult> => {
  const logger = Logger.getInstance();
  const contextManager = ContextManagerService.getInstance();

  try {
    // Check if user is already registered
    if (context.user.isRegistered) {
      return {
        success: true,
        message:
          `‚úÖ Ya est√°s registrado en el sistema, ${context.user.name}!\n\n` +
          `Usa \`!help\` para ver los comandos disponibles.`,
        data: { type: 'already_registered', userId: context.user.id },
      };
    }

    // Check if user already has an active registration context
    const activeContext = await contextManager.getActiveContext(
      context.user.id.toString()
    );
    if (
      activeContext &&
      activeContext.contextType === ContextType.REGISTRATION
    ) {
      return {
        success: true,
        message:
          `üîÑ Ya tienes un proceso de registro en curso.\n\n` +
          `Contin√∫a respondiendo a las preguntas o escribe \`!cancelar\` para empezar de nuevo.`,
        data: { type: 'registration_in_progress', contextId: activeContext.id },
      };
    }

    // Start registration context
    await contextManager.createSpecificContext(
      context.user.id.toString(),
      ContextType.REGISTRATION,
      {
        step: 'start',
        userId: context.user.id,
        startedAt: new Date().toISOString(),
      }
    );

    return {
      success: true,
      message:
        `üéâ **¬°Bienvenido al proceso de registro de DrasBot!**\n\n` +
        `Te ayudar√© a configurar tu cuenta paso a paso.\n\n` +
        `Para comenzar, ¬øcu√°l es tu nombre?`,
      data: {
        type: 'registration_started',
        userId: context.user.id,
        contextCreated: true,
      },
    };
  } catch (error) {
    logger.error(
      'RegistrationCommand',
      'Error executing registration command',
      { error }
    );
    return {
      success: false,
      message: 'Error al iniciar el registro. Int√©ntalo de nuevo.',
      data: { error: error instanceof Error ? error.message : String(error) },
    };
  }
};

/**
 * Command handler mapping
 */
export const commandHandlers = {
  help: handleHelpCommand,
  ayuda: handleHelpCommand,
  comandos: handleHelpCommand,

  status: handleStatusCommand,
  estado: handleStatusCommand,
  info: handleStatusCommand,

  config: handleConfigCommand,
  configuracion: handleConfigCommand,
  ajustes: handleConfigCommand,

  registro: handleRegistrationCommand,
  register: handleRegistrationCommand,
  registrar: handleRegistrationCommand,
  signup: handleRegistrationCommand,
};

export default commandHandlers;
